<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Connect Four</title>
    <style>
        :root {
            --bg: #1a1a2e;
            --board-blue: #2244ff;
            --slot-empty: #16213e;
            --red: #e94560;
            --yellow: #f9d342;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .header { text-align: center; margin-bottom: 20px; }
        h1 { margin: 0; font-size: 2.5rem; letter-spacing: 2px; }
        
        #status {
            font-size: 1.2rem;
            margin: 10px 0;
            padding: 5px 15px;
            border-radius: 20px;
            background: rgba(255,255,255,0.1);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        select, button {
            padding: 10px 15px;
            border-radius: 8px;
            border: none;
            font-weight: bold;
            cursor: pointer;
        }

        button { background: var(--red); color: white; }
        button:hover { opacity: 0.9; }

        /* The Board Logic */
        .board-container {
            position: relative;
            background: var(--board-blue);
            padding: 10px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: inline-block;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(7, 60px);
            grid-template-rows: repeat(6, 60px);
            gap: 10px;
        }

        .cell {
            width: 60px;
            height: 60px;
            background: var(--slot-empty);
            border-radius: 50%;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5);
            position: relative;
        }

        /* Clickable Columns */
        .click-layer {
            position: absolute;
            top: 0; left: 10px; right: 10px; bottom: 0;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            z-index: 10;
        }

        .col-hitbox {
            cursor: pointer;
            transition: background 0.2s;
        }
        .col-hitbox:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* The Pieces */
        .piece {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            position: absolute;
            top: 0; left: 0;
            transition: transform 0.5s cubic-bezier(0.5, 0, 0.5, 1.2);
            z-index: 5;
        }
        .red { background: var(--red); box-shadow: 0 4px 0 #b3304a; }
        .yellow { background: var(--yellow); box-shadow: 0 4px 0 #c7a935; }

        .win-highlight {
            animation: flash 0.5s infinite alternate;
            box-shadow: 0 0 20px white;
            z-index: 10;
        }

        @keyframes flash {
            from { filter: brightness(1); }
            to { filter: brightness(1.5); }
        }

        @media (max-width: 500px) {
            .grid { grid-template-columns: repeat(7, 12vw); grid-template-rows: repeat(6, 12vw); }
            .cell { width: 12vw; height: 12vw; }
            .piece { width: 12vw; height: 12vw; }
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>CONNECT 4</h1>
        <div id="status">Your Turn</div>
    </div>

    <div class="controls">
        <select id="diff">
            <option value="1">Level: Easy</option>
            <option value="4" selected>Level: Medium</option>
            <option value="7">Level: Hard</option>
        </select>
        <button onclick="reset()">Reset</button>
    </div>

    <div class="board-container">
        <!-- The background holes -->
        <div class="grid" id="bg-grid"></div>
        
        <!-- The interactive layer -->
        <div class="click-layer" id="click-layer"></div>
        
        <!-- Where pieces get injected -->
        <div id="piece-layer" style="position: absolute; top: 10px; left: 10px; pointer-events: none;"></div>
    </div>

    <script>
        const ROWS = 6;
        const COLS = 7;
        let board = [];
        let active = true;
        let turn = 1; // 1 = Player, 2 = AI

        const status = document.getElementById('status');
        const pieceLayer = document.getElementById('piece-layer');
        const bgGrid = document.getElementById('bg-grid');
        const clickLayer = document.getElementById('click-layer');

        function init() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            bgGrid.innerHTML = '';
            clickLayer.innerHTML = '';
            pieceLayer.innerHTML = '';
            active = true;
            turn = 1;
            status.innerText = "Your Turn";
            status.style.color = "white";

            // Create background and hitboxes
            for (let i = 0; i < ROWS * COLS; i++) {
                bgGrid.appendChild(document.createElement('div')).className = 'cell';
            }
            for (let c = 0; c < COLS; c++) {
                const hb = document.createElement('div');
                hb.className = 'col-hitbox';
                hb.onclick = () => playerMove(c);
                clickLayer.appendChild(hb);
            }
        }

        function playerMove(c) {
            if (!active || turn !== 1) return;
            if (makeMove(c, 1)) {
                if (checkWin(1)) return end("You Win!", "var(--red)");
                if (checkDraw()) return end("Draw!", "gray");
                
                turn = 2;
                status.innerText = "AI is thinking...";
                setTimeout(aiMove, 500);
            }
        }

        function makeMove(c, p) {
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r][c] === 0) {
                    board[r][c] = p;
                    animatePiece(r, c, p);
                    return true;
                }
            }
            return false;
        }

        function animatePiece(r, c, p) {
            const piece = document.createElement('div');
            piece.className = `piece ${p === 1 ? 'red' : 'yellow'}`;
            piece.id = `p-${r}-${c}`;
            
            // Calculate sizes based on viewport
            const cellSize = bgGrid.children[0].offsetWidth;
            const gap = 10;
            
            piece.style.left = `${c * (cellSize + gap)}px`;
            piece.style.transform = `translateY(-500px)`; // Start off-screen
            pieceLayer.appendChild(piece);

            // Trigger animation
            setTimeout(() => {
                piece.style.transform = `translateY(${r * (cellSize + gap)}px)`;
            }, 50);
        }

        function aiMove() {
            const level = parseInt(document.getElementById('diff').value);
            let col;

            // EASY MODE: Occasionally just picks a random column
            if (level === 1 && Math.random() > 0.5) {
                const valid = getValidCols();
                col = valid[Math.floor(Math.random() * valid.length)];
            } else {
                col = minimax(board, level, -Infinity, Infinity, true)[1];
            }

            if (col !== undefined) {
                makeMove(col, 2);
                if (checkWin(2)) return end("AI Wins!", "var(--yellow)");
                if (checkDraw()) return end("Draw!", "gray");
                turn = 1;
                status.innerText = "Your Turn";
            }
        }

        function getValidCols() {
            return [...Array(COLS).keys()].filter(c => board[0][c] === 0);
        }

        function checkWin(p) {
            // Horizontal
            for (let r = 0; r < ROWS; r++)
                for (let c = 0; c < COLS - 3; c++)
                    if (isFour(p, [r,c], [r,c+1], [r,c+2], [r,c+3])) return true;
            // Vertical
            for (let r = 0; r < ROWS - 3; r++)
                for (let c = 0; c < COLS; c++)
                    if (isFour(p, [r,c], [r+1,c], [r+2,c], [r+3,c])) return true;
            // Diag \
            for (let r = 0; r < ROWS - 3; r++)
                for (let c = 0; c < COLS - 3; c++)
                    if (isFour(p, [r,c], [r+1,c+1], [r+2,c+2], [r+3,c+3])) return true;
            // Diag /
            for (let r = 3; r < ROWS; r++)
                for (let c = 0; c < COLS - 3; c++)
                    if (isFour(p, [r,c], [r-1,c+1], [r-2,c+2], [r-3,c+3])) return true;
            return false;
        }

        function isFour(p, ...coords) {
            if (coords.every(([r,c]) => board[r][c] === p)) {
                if (active) { // Only highlight if game is actually ending
                    coords.forEach(([r,c]) => document.getElementById(`p-${r}-${c}`).classList.add('win-highlight'));
                }
                return true;
            }
            return false;
        }

        function checkDraw() { return board[0].every(c => c !== 0); }

        function end(msg, color) {
            active = false;
            status.innerText = msg;
            status.style.color = color;
        }

        function reset() { init(); }

        // --- AI LOGIC ---

        function scoreWindow(w, p) {
            const opp = p === 1 ? 2 : 1;
            let score = 0;
            const count = w.filter(x => x === p).length;
            const empty = w.filter(x => x === 0).length;
            const oppCount = w.filter(x => x === opp).length;

            if (count === 4) score += 1000;
            else if (count === 3 && empty === 1) score += 10;
            else if (count === 2 && empty === 2) score += 3;
            
            if (oppCount === 3 && empty === 1) score -= 80; // Block priority
            return score;
        }

        function evaluate(b, p) {
            let score = 0;
            // Center preference
            const center = b.map(r => r[3]).filter(x => x === p).length;
            score += center * 4;

            // Score rows/cols/diags...
            const windows = [];
            // Rows
            for (let r=0; r<6; r++) for (let c=0; c<4; c++) windows.push([b[r][c], b[r][c+1], b[r][c+2], b[r][c+3]]);
            // Cols
            for (let c=0; c<7; c++) for (let r=0; r<3; r++) windows.push([b[r][c], b[r+1][c], b[r+2][c], b[r+3][c]]);
            // Diags
            for (let r=0; r<3; r++) for (let c=0; c<4; c++) windows.push([b[r][c], b[r+1][c+1], b[r+2][c+2], b[r+3][c+3]]);
            for (let r=3; r<6; r++) for (let c=0; c<4; c++) windows.push([b[r][c], b[r-1][c+1], b[r-2][c+2], b[r-3][c+3]]);

            windows.forEach(w => score += scoreWindow(w, p));
            return score;
        }

        function minimax(b, depth, alpha, beta, max) {
            const win2 = checkWinSimple(b, 2);
            const win1 = checkWinSimple(b, 1);
            if (win2) return [100000, null];
            if (win1) return [-100000, null];
            if (depth === 0) return [evaluate(b, 2), null];

            const valid = getValidCols();
            if (valid.length === 0) return [0, null];

            if (max) {
                let best = -Infinity;
                let col = valid[0];
                for (let c of valid) {
                    let bc = b.map(r => [...r]);
                    for (let r=5; r>=0; r--) { if(bc[r][c]===0){bc[r][c]=2; break;} }
                    let s = minimax(bc, depth-1, alpha, beta, false)[0];
                    if (s > best) { best = s; col = c; }
                    alpha = Math.max(alpha, best);
                    if (alpha >= beta) break;
                }
                return [best, col];
            } else {
                let best = Infinity;
                let col = valid[0];
                for (let c of valid) {
                    let bc = b.map(r => [...r]);
                    for (let r=5; r>=0; r--) { if(bc[r][c]===0){bc[r][c]=1; break;} }
                    let s = minimax(bc, depth-1, alpha, beta, true)[0];
                    if (s < best) { best = s; col = c; }
                    beta = Math.min(beta, best);
                    if (alpha >= beta) break;
                }
                return [best, col];
            }
        }

        // Fast win check for AI recursion
        function checkWinSimple(b, p) {
            for (let r=0; r<6; r++) for (let c=0; c<4; c++) if (b[r][c]==p && b[r][c+1]==p && b[r][c+2]==p && b[r][c+3]==p) return true;
            for (let c=0; c<7; c++) for (let r=0; r<3; r++) if (b[r][c]==p && b[r+1][c]==p && b[r+2][c]==p && b[r+3][c]==p) return true;
            for (let r=0; r<3; r++) for (let c=0; c<4; c++) if (b[r][c]==p && b[r+1][c+1]==p && b[r+2][c+2]==p && b[r+3][c+3]==p) return true;
            for (let r=3; r<6; r++) for (let c=0; c<4; c++) if (b[r][c]==p && b[r-1][c+1]==p && b[r-2][c+2]==p && b[r-3][c+3]==p) return true;
            return false;
        }

        init();
    </script>
</body>
</html>
